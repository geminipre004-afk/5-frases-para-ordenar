<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Juego de Ordenar Frases</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
    <style>
      body {
        font-family: 'Fredoka One', cursive;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }
      /* Style for the item being dragged */
      .dragging {
        opacity: 0.5;
      }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.4/howler.min.js"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <link rel="stylesheet" href="/index.css">
</head>
  <body>
    <div id="root"></div>
    <script type="text/babel">
const { useState, useEffect, useCallback } = React;

// --- services/soundService ---
const soundService = {
  drag: new Howl({ src: ['https://cdn.jsdelivr.net/gh/dev-scopes/_public/projects/sort-the-sentence/assets/sounds/pick.mp3'], volume: 0.7 }),
  correctDrop: new Howl({ src: ['https://cdn.jsdelivr.net/gh/dev-scopes/_public/projects/sort-the-sentence/assets/sounds/drop.mp3'], volume: 0.7 }),
  incorrectDrop: new Howl({ src: ['https://cdn.jsdelivr.net/gh/dev-scopes/_public/projects/sort-the-sentence/assets/sounds/error.mp3'], volume: 0.4 }),
  success: new Howl({ src: ['https://cdn.jsdelivr.net/gh/dev-scopes/_public/projects/sort-the-sentence/assets/sounds/success.mp3'], volume: 0.6 }),
  error: new Howl({ src: ['https://cdn.jsdelivr.net/gh/dev-scopes/_public/projects/sort-the-sentence/assets/sounds/error.mp3'], volume: 0.6 }),

  // Helper function to unlock audio on user interaction, as required by modern browsers.
  _unlockAudio() {
    if (Howler.ctx && Howler.ctx.state !== 'running') {
      Howler.ctx.resume();
    }
  },

  playDrag() { this._unlockAudio(); this.drag.play(); },
  playCorrectDrop() { this._unlockAudio(); this.correctDrop.play(); },
  playIncorrectDrop() { this._unlockAudio(); this.incorrectDrop.play(); },
  playSuccess() { this._unlockAudio(); this.success.play(); },
  playError() { this._unlockAudio(); this.error.play(); },
};


// --- services/gameService ---
const gameRounds = [
  { correctWords: ["MY", "NAME", "IS", "ANA"] },
  { correctWords: ["MY", "FAVOURITE", "COLOUR", "IS", "BLUE"] },
  { correctWords: ["I'M", "9", "YEARS", "OLD"] },
  { correctWords: ["MY", "FAVOURITE", "FOOD", "IS", "PIZZA"] },
  { correctWords: ["I", "LIVE", "IN", "CÁCERES"] }
];

const shuffleArray = (array) => {
  const newArray = [...array];
  for (let i = newArray.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
  }
  return newArray;
};

const generateNewGameData = (round) => {
  const roundData = gameRounds[round - 1];
  const correctWords = roundData.correctWords;
  const allCards = shuffleArray([...correctWords]);
  return {
    correctWords,
    allCards,
  };
};


// --- components/WordCard ---
const WordCard = ({ word, isSelected, colorClass, isLongSentence }) => {
  const handleDragStart = (e) => {
    if (!isSelected) {
      soundService.playDrag();
      e.dataTransfer.setData("text/plain", word);
      e.currentTarget.classList.add('dragging');
    }
  };

  const handleDragEnd = (e) => {
      e.currentTarget.classList.remove('dragging');
  };

  const cardSizeClasses = isLongSentence
    ? "h-28 w-44 lg:h-32 lg:w-48"
    : "h-32 w-52 lg:h-36 lg:w-60";
    
  const fontSizeClasses = word.length > 8 
    ? "text-2xl lg:text-3xl"
    : "text-3xl lg:text-4xl";

  const baseClasses = `flex items-center justify-center p-2 text-center rounded-2xl shadow-lg cursor-grab transform transition-all duration-300 select-none font-bold text-gray-800 ${cardSizeClasses} ${fontSizeClasses}`;
  const stateClasses = isSelected
    ? "bg-gray-200 border-4 border-gray-300 text-gray-400 scale-95 opacity-60 cursor-not-allowed"
    : `${colorClass} border-4 hover:scale-105 hover:shadow-2xl active:scale-100 active:cursor-grabbing`;

  return (
    <div
      draggable={!isSelected}
      onDragStart={handleDragStart}
      onDragEnd={handleDragEnd}
      className={`${baseClasses} ${stateClasses}`}
    >
      {word}
    </div>
  );
};


// --- App.tsx ---
const GameStatus = {
  Playing: 0,
  Success: 1,
  Error: 2,
  GameOver: 3
};

const cardColors = [
    'bg-yellow-200 border-yellow-400', 'bg-green-200 border-green-400', 
    'bg-blue-200 border-blue-400', 'bg-pink-200 border-pink-400', 
    'bg-purple-200 border-purple-400', 'bg-indigo-200 border-indigo-400',
    'bg-red-200 border-red-400', 'bg-teal-200 border-teal-400',
    'bg-orange-200 border-orange-400', 'bg-cyan-200 border-cyan-400'
];

const SuccessIcon = () => (
  <svg className="w-28 h-28 lg:w-32 lg:w-32 text-green-500 mx-auto" fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
  </svg>
);

const ErrorIcon = () => (
  <svg className="w-28 h-28 lg:w-32 lg:w-32 text-red-500 mx-auto" fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" />
  </svg>
);

const App = () => {
  const [correctWords, setCorrectWords] = useState([]);
  const [shuffledCards, setShuffledCards] = useState([]);
  const [selectedWords, setSelectedWords] = useState([]);
  const [gameStatus, setGameStatus] = useState(GameStatus.Playing);
  const [draggedOverSlot, setDraggedOverSlot] = useState(null);
  const [justDroppedIndex, setJustDroppedIndex] = useState(null);
  const [currentRound, setCurrentRound] = useState(1);
  const totalRounds = 5;
  
  const isLongSentence = correctWords.length >= 5;

  const startNewGame = useCallback((round) => {
    const { correctWords: newCorrectWords, allCards } = generateNewGameData(round);
    setCorrectWords(newCorrectWords);
    setShuffledCards(allCards);
    setSelectedWords(Array(newCorrectWords.length).fill(null));
    setGameStatus(GameStatus.Playing);
  }, []);

  useEffect(() => {
    startNewGame(currentRound);
  }, [currentRound, startNewGame]);

  useEffect(() => {
    if (selectedWords.includes(null) || correctWords.length === 0) {
      return;
    }

    const isCorrect = selectedWords.every((word, index) => word === correctWords[index]);
    if (isCorrect) {
      soundService.playSuccess();
      setGameStatus(GameStatus.Success);
    } else {
      soundService.playError();
      setGameStatus(GameStatus.Error);
    }
  }, [selectedWords, correctWords]);

  useEffect(() => {
    if (justDroppedIndex !== null) {
      const timer = setTimeout(() => {
        setJustDroppedIndex(null);
      }, 300);
      return () => clearTimeout(timer);
    }
  }, [justDroppedIndex]);

  const handleRetry = () => {
    setSelectedWords(Array(correctWords.length).fill(null));
    setGameStatus(GameStatus.Playing);
  };

  const handleNextRound = () => {
    if (currentRound < totalRounds) {
        setCurrentRound(prev => prev + 1);
    } else {
        setGameStatus(GameStatus.GameOver);
        soundService.playSuccess();
    }
  };

  const handlePlayAgain = () => {
    setCurrentRound(1);
  };

  const handleDragOver = (e) => {
    e.preventDefault();
  };
  
  const handleDropOutside = (e) => {
      e.preventDefault();
      const moveDataJSON = e.dataTransfer.getData("application/json");

      if (moveDataJSON) {
          const { fromIndex } = JSON.parse(moveDataJSON);
          const newSelectedWords = [...selectedWords];
          newSelectedWords[fromIndex] = null;
          setSelectedWords(newSelectedWords);
          soundService.playCorrectDrop();
      }
  };

  const handleDrop = (e, dropIndex) => {
    e.preventDefault();
    e.stopPropagation();
    setDraggedOverSlot(null);

    // Case 1: A card is being moved from another slot
    const moveDataJSON = e.dataTransfer.getData("application/json");
    if (moveDataJSON) {
        const { word, fromIndex } = JSON.parse(moveDataJSON);
        if (fromIndex === dropIndex) return; // Dropped in the same spot

        const newSelectedWords = [...selectedWords];
        // Swap cards between slots
        const wordAtDropIndex = newSelectedWords[dropIndex];
        newSelectedWords[dropIndex] = word;
        newSelectedWords[fromIndex] = wordAtDropIndex; // This could be null, which is fine

        setSelectedWords(newSelectedWords);
        soundService.playCorrectDrop();
        setJustDroppedIndex(dropIndex);
        return;
    }

    // Case 2: A new card is being dropped from the pool
    const draggedWord = e.dataTransfer.getData("text/plain");
    if (draggedWord) {
        // Prevent dropping a new card on an already occupied slot
        if (selectedWords[dropIndex]) {
            soundService.playIncorrectDrop();
            return;
        }
        
        soundService.playCorrectDrop();

        const newSelectedWords = [...selectedWords];
        newSelectedWords[dropIndex] = draggedWord;
        setSelectedWords(newSelectedWords);
        setJustDroppedIndex(dropIndex);
    }
  };
  
  const handleCardDragStart = (e, word, fromIndex) => {
    soundService.playDrag();
    // Use JSON to store both word and its origin index
    e.dataTransfer.setData("application/json", JSON.stringify({ word, fromIndex }));
    e.currentTarget.classList.add('dragging');
  };

  const handleCardDragEnd = (e) => {
    e.currentTarget.classList.remove('dragging');
  };
  
  const renderDropZone = () => {
    const slotSizeClasses = isLongSentence
        ? 'h-28 w-44 lg:h-32 lg:w-48'
        : 'h-32 w-52 lg:h-36 lg:w-60';
    const containerGapClass = isLongSentence ? 'gap-2 lg:gap-4' : 'gap-4 lg:gap-6';

    return (
        <div className={`flex justify-center items-center flex-wrap ${containerGapClass} h-auto min-h-[11rem] lg:min-h-[12rem] bg-white/60 rounded-2xl p-4 shadow-inner my-8`}>
        {correctWords.length > 0 ? (
            correctWords.map((_, index) => {
            const word = selectedWords[index];
            const isJustDropped = justDroppedIndex === index;
            const isDraggedOver = draggedOverSlot === index;
            
            const droppedCardFontSizeClasses = word && word.length > 8
                ? "text-2xl lg:text-3xl"
                : isLongSentence
                    ? "text-3xl lg:text-4xl"
                    : "text-4xl lg:text-5xl";
            
            return (
                <div
                key={index}
                onDragOver={handleDragOver}
                onDrop={(e) => handleDrop(e, index)}
                onDragEnter={() => setDraggedOverSlot(index)}
                onDragLeave={() => setDraggedOverSlot(null)}
                className={`flex items-center justify-center ${slotSizeClasses} rounded-2xl transition-all duration-200
                    ${
                    word
                        ? 'bg-transparent border-0'
                        : `bg-white/70 border-4 border-dashed ${isDraggedOver ? 'border-blue-500 scale-105' : 'border-gray-400'}`
                    }
                `}
                >
                {word && (
                    <div
                        draggable
                        onDragStart={(e) => handleCardDragStart(e, word, index)}
                        onDragEnd={handleCardDragEnd}
                        className={`flex items-center justify-center h-full w-full p-2 text-center rounded-xl bg-white border-4 text-gray-800 shadow-md font-bold cursor-grab active:cursor-grabbing transition-all duration-200 ${droppedCardFontSizeClasses}
                        ${isJustDropped ? 'border-green-500 scale-110' : 'border-green-400'}
                        ${isDraggedOver ? 'ring-4 ring-blue-500' : ''}
                        `}
                    >
                        {word}
                    </div>
                )}
                </div>
            );
            })
        ) : (
            <div className="text-gray-500">Cargando juego...</div>
        )}
        </div>
    );
  };

  const renderFeedbackOverlay = () => {
    if (gameStatus === GameStatus.Playing) return null;

    const isSuccess = gameStatus === GameStatus.Success;
    const isError = gameStatus === GameStatus.Error;
    const isGameOver = gameStatus === GameStatus.GameOver;

    let icon, title, message, buttonText, buttonOnClick, buttonColorClass, titleColorClass;

    if (isSuccess) {
        icon = <SuccessIcon />;
        title = '¡MUY BIEN!';
        message = '¡Has ordenado la frase correctamente!';
        buttonText = 'Siguiente';
        buttonOnClick = handleNextRound;
        buttonColorClass = 'bg-blue-500 hover:bg-blue-600';
        titleColorClass = 'text-green-500';
    } else if (isError) {
        icon = <ErrorIcon />;
        title = '¡UPS!';
        message = 'Ese no es el orden correcto.';
        buttonText = 'Reintentar';
        buttonOnClick = handleRetry;
        buttonColorClass = 'bg-orange-500 hover:bg-orange-600';
        titleColorClass = 'text-red-500';
    } else if (isGameOver) {
        icon = <SuccessIcon />;
        title = '¡FELICIDADES!';
        message = `¡Has completado todas las ${totalRounds} rondas!`;
        buttonText = 'Jugar de Nuevo';
        buttonOnClick = handlePlayAgain;
        buttonColorClass = 'bg-green-500 hover:bg-green-600';
        titleColorClass = 'text-green-500';
    }

    return (
      <div className="absolute inset-0 bg-black/40 flex items-center justify-center z-10 p-4 transition-opacity duration-300">
        <div className="bg-white p-8 lg:p-12 rounded-3xl shadow-2xl text-center max-w-md lg:max-w-lg w-full transform transition-all scale-100">
          {icon}
          <h2 className={`text-5xl lg:text-6xl font-bold my-4 ${titleColorClass}`}>
            {title}
          </h2>
          <p className="text-gray-600 text-2xl lg:text-3xl mb-8">
            {message}
          </p>
          <button
            onClick={buttonOnClick}
            className={`w-full py-5 px-6 rounded-2xl text-white text-3xl font-bold shadow-lg transform hover:scale-105 transition-transform duration-200
              ${buttonColorClass}`}
          >
            {buttonText}
          </button>
        </div>
      </div>
    );
  };

  return (
    <div className="min-h-screen bg-sky-100 text-gray-800 p-4 sm:p-6 lg:p-8 xl:p-12 overflow-hidden relative" onClick={soundService._unlockAudio}>
      <div className="max-w-7xl mx-auto">
        <header className="text-center my-4">
          <h1 className="text-6xl sm:text-7xl lg:text-8xl font-bold text-sky-600 drop-shadow-lg">Ordena la Frase</h1>
          <p className="text-2xl lg:text-3xl text-sky-500 mt-2">Arrastra las palabras al orden correcto.</p>
          <p className="text-3xl lg:text-4xl text-sky-600 font-semibold mt-4">Ronda {currentRound} / {totalRounds}</p>
        </header>
        
        <main onDrop={handleDropOutside} onDragOver={handleDragOver}>
          {renderDropZone()}
          <div className={`flex flex-wrap justify-center ${isLongSentence ? 'gap-2 lg:gap-4' : 'gap-4 lg:gap-6'}`}>
            {shuffledCards.map((word, index) => (
              <WordCard
                key={`${word}-${index}`}
                word={word}
                isSelected={selectedWords.includes(word)}
                colorClass={cardColors[index % cardColors.length]}
                isLongSentence={isLongSentence}
              />
            ))}
          </div>
        </main>
      </div>
      {renderFeedbackOverlay()}
    </div>
  );
};

// --- index.tsx ---
const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}

const root = ReactDOM.createRoot(rootElement);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
    </script>
  <script type="module" src="/index.tsx"></script>
</body>
</html>